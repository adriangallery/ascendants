<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdrianLab Trait Admin</title>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 56px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00aaff, #ff0088);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 200%;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 20px;
            margin-bottom: 20px;
        }

        .admin-section {
            background: rgba(20, 20, 20, 0.8);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .section-title {
            font-size: 24px;
            color: #00ff88;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #888;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00ff88;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 16px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00ff88, #00aaff);
            color: #000;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff0088, #ff8800);
            color: #fff;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 0, 136, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            padding: 20px;
            border-radius: 12px;
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .status.error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            color: #ff4444;
        }

        .status.info {
            background: rgba(0, 170, 255, 0.1);
            border: 1px solid rgba(0, 170, 255, 0.3);
            color: #00aaff;
        }

        .wallet-section {
            background: rgba(20, 20, 20, 0.8);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .connect-btn {
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(45deg, #ff0088, #ff8800);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 0, 136, 0.3);
        }

        .wallet-info {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .wallet-address {
            font-family: monospace;
            font-size: 16px;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            padding: 8px 16px;
            border-radius: 8px;
        }

        .owner-status {
            color: #00aaff;
            font-weight: 600;
        }

        .owner-only {
            display: none;
        }

        .owner-only.active {
            display: block;
        }

        .debug-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            color: #888;
        }

        .contract-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .contract-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .contract-title {
            color: #00ff88;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .contract-address {
            font-family: monospace;
            font-size: 12px;
            color: #888;
            word-break: break-all;
        }

        /* NUEVOS ESTILOS PARA CATEGOR√çAS */
        .categories-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .category-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin-bottom: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .category-name {
            font-weight: 600;
            color: #00ff88;
        }

        .remove-category-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: linear-gradient(45deg, #ff0088, #ff4444);
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .remove-category-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(255, 0, 136, 0.4);
        }

        .category-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .category-actions input {
            flex: 1;
        }

        .category-actions button {
            flex: 0 0 auto;
            min-width: 120px;
        }

        .remove-category-section {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 0, 0, 0.05);
            border: 1px solid rgba(255, 0, 0, 0.2);
            border-radius: 12px;
        }

        .remove-section-title {
            color: #ff4444;
            font-size: 18px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .warning-text {
            color: #ff8888;
            font-size: 14px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AdrianLab</h1>
            <p class="subtitle">Trait Administration Panel</p>
        </div>

        <div class="wallet-section">
            <div id="connect-section">
                <button class="connect-btn" onclick="connectWallet()">Connect Wallet</button>
                <div class="debug-info">
                    <div>Debug Info:</div>
                    <div>MetaMask: <span id="metamask-status">Checking...</span></div>
                    <div>Ethers: <span id="ethers-status">Checking...</span></div>
                    <div>Network: <span id="network-status">-</span></div>
                    <div>Contract Status: <span id="contract-status">-</span></div>
                    <div>Owner Check: <span id="owner-check-status">-</span></div>
                    <button class="btn-secondary" onclick="forceEnableAdmin()" style="margin-top: 10px; font-size: 12px; padding: 8px 16px;">
                        Force Enable Admin Panel
                    </button>
                </div>
            </div>
            <div id="wallet-connected" style="display: none;">
                <div class="wallet-info">
                    <div class="wallet-address" id="wallet-address"></div>
                    <div class="owner-status" id="owner-status"></div>
                </div>
                
                <div class="contract-info">
                    <div class="contract-card">
                        <div class="contract-title">AdrianTraitsCore</div>
                        <div class="contract-address" id="traits-core-address">-</div>
                        <div>Status: <span id="traits-core-status">-</span></div>
                    </div>
                    <div class="contract-card">
                        <div class="contract-title">AdrianTraitsExtensions</div>
                        <div class="contract-address" id="traits-ext-address">-</div>
                        <div>Status: <span id="traits-ext-status">-</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="admin-panel" class="owner-only">
            <!-- Test Section -->
            <div class="admin-section">
                <h2 class="section-title">Contract Testing</h2>
                <div class="button-group">
                    <button class="btn-secondary" onclick="testContractConnection()">Test Contract Connection</button>
                    <button class="btn-secondary" onclick="checkRealOwnership()">Check Real Ownership</button>
                    <button class="btn-secondary" onclick="testReadFunction()">Test Read Function</button>
                </div>
                <div id="test-results" style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; font-family: monospace; font-size: 12px; display: none;"></div>
            </div>

            <!-- SECCI√ìN DE CATEGOR√çAS ACTUALIZADA -->
            <div class="admin-section">
                <h2 class="section-title">Manage Categories</h2>
                
                <!-- Agregar categor√≠a -->
                <div class="category-actions">
                    <input type="text" id="category-name" placeholder="Enter category name (e.g., CLOTHING, ACCESSORIES)">
                    <button class="btn-primary" onclick="addCategory()">Add Category</button>
                    <button class="btn-secondary" onclick="refreshCategoriesWithRetry()">Refresh</button>
                </div>

                <!-- Lista de categor√≠as actuales -->
                <div class="categories-display">
                    <h4 style="color: #00aaff; margin-bottom: 15px;">Current Categories:</h4>
                    <div id="categories-list">
                        <p style="color: #888;">Loading categories...</p>
                    </div>
                </div>

                <!-- Secci√≥n para eliminar categor√≠as -->
                <div class="remove-category-section">
                    <h4 class="remove-section-title">‚ö†Ô∏è Remove Category (Danger Zone)</h4>
                    <div class="warning-text">
                        <strong>Warning:</strong> Removing a category will make it unavailable for new traits. 
                        Existing traits with this category will not be affected, but you won't be able to create new ones.
                    </div>
                    <div class="form-group">
                        <label for="remove-category-select">Select Category to Remove</label>
                        <select id="remove-category-select">
                            <option value="">Select a category to remove</option>
                        </select>
                    </div>
                    <button class="btn-danger" onclick="removeCategory()" style="width: 100%;">
                        üóëÔ∏è Remove Selected Category
                    </button>
                </div>
            </div>

            <!-- Secci√≥n de Traits -->
            <div class="admin-section">
                <h2 class="section-title">Create Traits</h2>
                <div class="form-group">
                    <label for="trait-id">Trait ID (1-99999)</label>
                    <input type="number" id="trait-id" min="1" max="99999" placeholder="Enter trait ID">
                </div>
                <div class="form-group">
                    <label for="trait-name">Trait Name</label>
                    <input type="text" id="trait-name" placeholder="Enter trait name">
                </div>
                <div class="form-group">
                    <label for="trait-category">Category</label>
                    <select id="trait-category">
                        <option value="">Select a category</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="trait-max-supply">Max Supply (0 = unlimited)</label>
                    <input type="number" id="trait-max-supply" min="0" placeholder="Enter max supply">
                </div>
                <div class="button-group">
                    <button class="btn-primary" onclick="createTrait()">Create Trait</button>
                </div>
            </div>

            <!-- Secci√≥n de Create Pack -->
            <div class="admin-section">
                <h2 class="section-title">Create Pack</h2>
                <div class="form-group">
                    <label for="pack-id">Pack ID (100000-109999)</label>
                    <input type="number" id="pack-id" min="100000" max="109999" placeholder="Enter pack ID">
                </div>
                <div class="form-group">
                    <label for="trait-ids">Trait IDs (comma separated)</label>
                    <input type="text" id="trait-ids" placeholder="e.g., 1,2,3,4,5">
                </div>
                <div class="button-group">
                    <button class="btn-primary" onclick="createPack()">Create Pack</button>
                </div>
            </div>

            <!-- Secci√≥n de Pack Contents -->
            <div class="admin-section">
                <h2 class="section-title">Configure Pack Contents</h2>
                <div class="form-group">
                    <label for="config-pack-id">Pack ID</label>
                    <input type="number" id="config-pack-id" min="100000" max="109999" placeholder="Enter pack ID">
                </div>
                <div class="form-group">
                    <label for="trait-ids">Trait IDs (comma separated)</label>
                    <input type="text" id="trait-ids" placeholder="e.g., 1,2,3,4,5">
                </div>
                <div class="form-group">
                    <label for="min-amounts">Min Amounts (comma separated)</label>
                    <input type="text" id="min-amounts" placeholder="e.g., 1,1,1,2,1">
                </div>
                <div class="form-group">
                    <label for="max-amounts">Max Amounts (comma separated)</label>
                    <input type="text" id="max-amounts" placeholder="e.g., 1,2,1,3,2">
                </div>
                <div class="form-group">
                    <label for="trait-chances">Chances % (comma separated)</label>
                    <input type="text" id="trait-chances" placeholder="e.g., 100,50,30,20,10">
                </div>
                <div class="form-group">
                    <label for="pool-amounts">Pool Amounts (comma separated)</label>
                    <input type="text" id="pool-amounts" placeholder="e.g., 1000,500,300,200,100">
                </div>
                <div class="button-group">
                    <button class="btn-primary" onclick="addPackTraits()">Configure Pack Traits</button>
                </div>
            </div>
        </div>

        <div id="status" class="status"></div>
    </div>

    <script>
        // Contract addresses - ACTUALIZADAS
        const ADRIAN_TOKEN = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
        const TRAITS_CORE = "0xb72be829f06a6c5baf99cdae204ffd99ea4a6c9a";
        const TRAITS_EXTENSIONS = "0x756e1a4fC47cbDe7d503b6c1B0353aDa94B41630";

        // ABIs simplificados y actualizados - AGREGADA removeCategory
        const TRAITS_CORE_ABI = [
            // Funciones b√°sicas
            "function owner() view returns (address)",
            "function balanceOf(address account, uint256 id) view returns (uint256)",
            
            // Gesti√≥n de categor√≠as
            "function addCategory(string calldata category) external",
            "function removeCategory(string calldata category) external", // ‚úÖ AGREGADA
            "function getCategoryList() external view returns (string[] memory)",
            "function validCategories(string memory category) external view returns (bool)",
            
            // Gesti√≥n de assets
            "function createAsset(uint256 assetId, string calldata name, string calldata category, uint256 maxSupply) external",
            "function getAssetData(uint256 assetId) external view returns (tuple(string name, string category, string ipfsPath, bool tempFlag, uint256 maxSupply, uint8 assetType, string metadata))",
            "function getName(uint256 assetId) external view returns (string memory)",
            "function getCategory(uint256 assetId) external view returns (string memory)",
            "function getTraitInfo(uint256 assetId) external view returns (string memory category, bool isTemp)",
            
            // Gesti√≥n de packs
            "function createPack(uint256 packId, uint256 price, uint256 maxSupply, uint256 itemsPerPack, uint256 maxPerWallet, bool requiresAllowlist) external",
            "function addPackTraits(uint256 packId, uint256[] calldata traitIds, uint256[] calldata minAmounts, uint256[] calldata maxAmounts, uint256[] calldata chances, uint256[] calldata poolAmounts) external",
            "function getPackInfo(uint256 packId) external view returns (uint256 price, uint256 maxSupply, uint256 minted, uint256 itemsPerPack, uint256 maxPerWallet, bool active, bool requiresAllowlist)"
        ];

        const TRAITS_EXTENSIONS_ABI = [
            // Funciones b√°sicas
            "function owner() view returns (address)",
            "function balanceOf(address account, uint256 id) view returns (uint256)",
            
            // Gesti√≥n de traits
            "function createTrait(uint256 traitId, string memory name, string memory category, uint256 maxSupply) external",
            "function getTraitInfo(uint256 traitId) external view returns (tuple(string name, string category, uint256 maxSupply, bool isPack))",
            "function getTraitSupply(uint256 traitId) external view returns (uint256)",
            
            // Gesti√≥n de packs
            "function createPack(uint256 packId, uint256[] calldata contents) external",
            "function getPackContents(uint256 packId) external view returns (uint256[] memory)"
        ];

        // Global variables
        let provider;
        let signer;
        let traitsCore;
        let traitsExtensions;
        let userAddress;

        async function connectWallet() {
            try {
                showStatus('Conectando wallet...', 'info');

                // Request account access
                let accounts;
                try {
                    accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });
                } catch (error) {
                    if (error.code === 4001) {
                        showStatus('Conexi√≥n rechazada por el usuario', 'error');
                    } else {
                        showStatus('Error al conectar: ' + error.message, 'error');
                    }
                    return;
                }

                if (!accounts || accounts.length === 0) {
                    showStatus('No hay cuentas disponibles', 'error');
                    return;
                }

                // Setup provider and signer
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await checkNetwork();
                
                signer = provider.getSigner();
                userAddress = await signer.getAddress();

                console.log('Direcci√≥n conectada:', userAddress);

                // Initialize contracts
                try {
                    traitsCore = new ethers.Contract(TRAITS_CORE, TRAITS_CORE_ABI, signer);
                    traitsExtensions = new ethers.Contract(TRAITS_EXTENSIONS, TRAITS_EXTENSIONS_ABI, signer);
                    
                    console.log('Contratos inicializados exitosamente');
                    
                    // Update contract info in UI
                    document.getElementById('traits-core-address').textContent = TRAITS_CORE;
                    document.getElementById('traits-ext-address').textContent = TRAITS_EXTENSIONS;
                    document.getElementById('traits-core-status').textContent = 'Conectado ‚úì';
                    document.getElementById('traits-core-status').style.color = '#00ff88';
                    document.getElementById('traits-ext-status').textContent = 'Conectado ‚úì';
                    document.getElementById('traits-ext-status').style.color = '#00ff88';
                    
                } catch (error) {
                    console.error('Error al inicializar contratos:', error);
                    showStatus('Error al inicializar contratos: ' + error.message, 'error');
                    return;
                }

                // Update UI
                const shortAddress = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
                document.getElementById('wallet-address').textContent = shortAddress;
                document.getElementById('connect-section').style.display = 'none';
                document.getElementById('wallet-connected').style.display = 'block';
                document.getElementById('admin-panel').classList.add('active');
                await loadCategories();
                showStatus('¬°Conectado exitosamente!', 'success');
            } catch (error) {
                console.error('Error inesperado durante la conexi√≥n:', error);
                showStatus('Error inesperado: ' + error.message, 'error');
            }
        }

        // Function with user feedback for manual refresh
        async function refreshCategoriesWithRetry() {
            showStatus('Refreshing categories...', 'info');
            try {
                await loadCategories();
                showStatus('Categories refreshed successfully!', 'success');
            } catch (error) {
                showStatus('Failed to refresh categories. Please try again.', 'error');
            }
        }

        // Check network
        async function checkNetwork() {
            try {
                if (!provider) return;
                
                const network = await provider.getNetwork();
                const networkStatus = document.getElementById('network-status');
                networkStatus.textContent = `${network.name} (${network.chainId})`;
                
            } catch (error) {
                console.error('Error checking network:', error);
                document.getElementById('network-status').textContent = 'Error';
            }
        }

        async function loadCategories() {
            try {
                console.log('Loading categories from TraitsCore...');
                
                if (!traitsCore) {
                    console.log('No TraitsCore contract available');
                    return;
                }
                
                // Add retry logic for rate limiting
                let categories;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        categories = await traitsCore.getCategoryList();
                        break; // Success, exit retry loop
                    } catch (error) {
                        retryCount++;
                        if (error.message.includes('rate limited') && retryCount < maxRetries) {
                            console.log(`Rate limited, retrying in ${retryCount * 1000}ms... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryCount * 1000));
                            continue;
                        }
                        throw error; // Re-throw if not rate limit or max retries reached
                    }
                }
                
                console.log('Categories loaded:', categories);
                
                // Update category select for creating traits
                const categorySelect = document.getElementById('trait-category');
                if (categorySelect) {
                    categorySelect.innerHTML = '<option value="">Select a category</option>';
                    
                    categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        categorySelect.appendChild(option);
                    });
                }
                
                // Update remove category select
                const removeCategorySelect = document.getElementById('remove-category-select');
                if (removeCategorySelect) {
                    removeCategorySelect.innerHTML = '<option value="">Select a category to remove</option>';
                    
                    categories.forEach(category => {
                        const removeOption = document.createElement('option');
                        removeOption.value = category;
                        removeOption.textContent = category;
                        removeCategorySelect.appendChild(removeOption);
                    });
                }
                
                // Update categories display with individual remove buttons
                const categoriesList = document.getElementById('categories-list');
                if (categoriesList) {
                    if (categories.length > 0) {
                        // Clear existing content
                        categoriesList.innerHTML = '';
                        
                        // Create elements programmatically to avoid quote issues
                        categories.forEach(category => {
                            const categoryItem = document.createElement('div');
                            categoryItem.className = 'category-item';
                            
                            const categoryName = document.createElement('span');
                            categoryName.className = 'category-name';
                            categoryName.textContent = category;
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.className = 'remove-category-btn';
                            removeBtn.textContent = 'Remove';
                            removeBtn.addEventListener('click', () => removeCategoryDirect(category));
                            
                            categoryItem.appendChild(categoryName);
                            categoryItem.appendChild(removeBtn);
                            categoriesList.appendChild(categoryItem);
                        });
                    } else {
                        categoriesList.innerHTML = '<p style="color: #888;">No categories found</p>';
                    }
                }
                
                console.log('Categories UI updated');
            } catch (error) {
                console.error('Error loading categories:', error);
                
                // More specific error handling
                let errorMessage = 'Failed to load categories: ';
                if (error.message.includes('rate limited')) {
                    errorMessage += 'MetaMask is being rate limited. Please wait a moment and try again.';
                } else if (error.message.includes('missing revert data')) {
                    errorMessage += 'Contract call failed. Please check your network connection and try again.';
                } else if (error.message.includes('CALL_EXCEPTION')) {
                    errorMessage += 'Contract interaction failed. The contract might not be deployed or accessible.';
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
                
                // Set fallback UI
                const categoriesList = document.getElementById('categories-list');
                if (categoriesList) {
                    categoriesList.innerHTML = '<p style="color: #ff4444;">Error loading categories. <button class="btn-secondary" onclick="loadCategories()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">Retry</button></p>';
                }
            }
        }

        async function addCategory() {
            try {
                if (!traitsCore) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                const name = document.getElementById('category-name').value.trim().toUpperCase();
                if (!name) {
                    showStatus('Please enter a category name', 'error');
                    return;
                }
                showStatus('Enviando transacci√≥n para agregar categor√≠a...', 'info');
                const tx = await traitsCore.addCategory(name);
                showStatus(`Transacci√≥n enviada: <a href='https://routescan.io/tx/${tx.hash}' target='_blank' class='tx-link'>${tx.hash.slice(0, 10)}...</a>`, 'info');
                await tx.wait();
                showStatus('¬°Categor√≠a agregada exitosamente!', 'success');
                document.getElementById('category-name').value = '';
                await loadCategories();
            } catch (error) {
                let errorMessage = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMessage = 'La transacci√≥n fallar√≠a - revisa permisos o si la categor√≠a ya existe';
                } else if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage = 'Fondos insuficientes para gas';
                } else if (error.code === 4001) {
                    errorMessage = 'Transacci√≥n rechazada por el usuario';
                } else if (error.message.includes('onlyOwner')) {
                    errorMessage = 'Acceso denegado - no eres el owner del contrato';
                } else if (error.message.includes('execution reverted')) {
                    errorMessage = 'Transacci√≥n revertida - revisa permisos o si la categor√≠a ya existe';
                }
                showStatus('Error al agregar categor√≠a: ' + errorMessage, 'error');
            }
        }

        // ‚úÖ NUEVA FUNCI√ìN: Eliminar categor√≠a desde el dropdown
        async function removeCategory() {
            try {
                if (!traitsCore) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                
                const categoryToRemove = document.getElementById('remove-category-select').value;
                if (!categoryToRemove) {
                    showStatus('Please select a category to remove', 'error');
                    return;
                }
                
                // Confirmaci√≥n adicional
                const confirmation = confirm(`Are you sure you want to remove the category "${categoryToRemove}"?\n\nThis action cannot be undone. Existing traits with this category will not be affected, but you won't be able to create new traits with this category.`);
                if (!confirmation) {
                    return;
                }
                
                showStatus('Sending transaction to remove category...', 'info');
                
                // Add timeout and better error handling
                const tx = await Promise.race([
                    traitsCore.removeCategory(categoryToRemove),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Transaction timeout')), 30000)
                    )
                ]);
                
                showStatus(`Transaction sent: <a href='https://routescan.io/tx/${tx.hash}' target='_blank' class='tx-link'>${tx.hash.slice(0, 10)}...</a>`, 'info');
                
                // Wait for confirmation with timeout
                await Promise.race([
                    tx.wait(),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Confirmation timeout')), 60000)
                    )
                ]);
                
                showStatus('Category removed successfully!', 'success');
                
                // Reset dropdown
                document.getElementById('remove-category-select').value = '';
                
                // Reload categories with delay to avoid rate limiting
                setTimeout(() => loadCategories(), 1000);
                
            } catch (error) {
                console.error('Error removing category:', error);
                let errorMessage = 'Error removing category: ';
                
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMessage += 'Transaction would fail - check permissions or if category exists';
                } else if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas';
                } else if (error.code === 4001) {
                    errorMessage += 'Transaction rejected by user';
                } else if (error.message.includes('onlyOwner')) {
                    errorMessage += 'Access denied - you are not the contract owner';
                } else if (error.message.includes('Category does not exist')) {
                    errorMessage += 'Category does not exist';
                } else if (error.message.includes('execution reverted')) {
                    errorMessage += 'Transaction reverted - check permissions or if category exists';
                } else if (error.message.includes('rate limited')) {
                    errorMessage += 'MetaMask is being rate limited. Please wait a moment and try again.';
                } else if (error.message.includes('timeout')) {
                    errorMessage += 'Transaction timeout. Please check transaction status manually.';
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
            }
        }

        // ‚úÖ NUEVA FUNCI√ìN: Eliminar categor√≠a directamente desde la lista
        async function removeCategoryDirect(categoryName) {
            try {
                if (!traitsCore) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                
                if (!categoryName || categoryName.trim() === '') {
                    showStatus('Invalid category name', 'error');
                    return;
                }
                
                // Confirmaci√≥n
                const confirmation = confirm(`Remove category "${categoryName}"?\n\nThis action cannot be undone. Existing traits with this category will not be affected, but you won't be able to create new traits with this category.`);
                if (!confirmation) {
                    return;
                }
                
                showStatus('Removing category...', 'info');
                
                // Add timeout and better error handling
                const tx = await Promise.race([
                    traitsCore.removeCategory(categoryName),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Transaction timeout')), 30000)
                    )
                ]);
                
                showStatus(`Transaction sent: <a href='https://routescan.io/tx/${tx.hash}' target='_blank' class='tx-link'>${tx.hash.slice(0, 10)}...</a>`, 'info');
                
                // Wait for confirmation with timeout
                await Promise.race([
                    tx.wait(),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Confirmation timeout')), 60000)
                    )
                ]);
                
                showStatus('Category removed successfully!', 'success');
                
                // Reload categories with delay to avoid rate limiting
                setTimeout(() => loadCategories(), 1000);
                
            } catch (error) {
                console.error('Error removing category:', error);
                let errorMessage = 'Error removing category: ';
                
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMessage += 'Transaction would fail - check permissions or if category exists';
                } else if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas';
                } else if (error.code === 4001) {
                    errorMessage += 'Transaction rejected by user';
                } else if (error.message.includes('onlyOwner')) {
                    errorMessage += 'Access denied - you are not the contract owner';
                } else if (error.message.includes('Category does not exist')) {
                    errorMessage += 'Category does not exist';
                } else if (error.message.includes('execution reverted')) {
                    errorMessage += 'Transaction reverted - check permissions or if category exists';
                } else if (error.message.includes('rate limited')) {
                    errorMessage += 'MetaMask is being rate limited. Please wait a moment and try again.';
                } else if (error.message.includes('timeout')) {
                    errorMessage += 'Transaction timeout. Please check transaction status manually.';
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
            }
        }

        async function createTrait() {
            try {
                console.log('createTrait called');
                
                if (!traitsCore) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                
                const traitId = document.getElementById('trait-id').value;
                const name = document.getElementById('trait-name').value.trim();
                const category = document.getElementById('trait-category').value;
                const maxSupply = document.getElementById('trait-max-supply').value || '0';

                if (!traitId || !name || !category) {
                    showStatus('Please fill all required fields', 'error');
                    return;
                }

                if (parseInt(traitId) < 1 || parseInt(traitId) > 99999) {
                    showStatus('Trait ID must be between 1 and 99999', 'error');
                    return;
                }

                showStatus('Creating trait...', 'info');
                
                const tx = await traitsCore.createAsset(
                    parseInt(traitId),
                    name,
                    category,
                    parseInt(maxSupply)
                );
                showStatus('Transaction sent, waiting for confirmation...', 'info');
                
                await tx.wait();
                
                showStatus('Trait created successfully!', 'success');
                
                // Clear form
                document.getElementById('trait-id').value = '';
                document.getElementById('trait-name').value = '';
                document.getElementById('trait-category').value = '';
                document.getElementById('trait-max-supply').value = '';
                
            } catch (error) {
                console.error('Error creating trait:', error);
                showStatus('Failed to create trait: ' + error.message, 'error');
            }
        }

        async function createPack() {
            try {
                console.log('createPack called');
                
                if (!traitsExtensions) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                
                const packId = document.getElementById('pack-id').value;
                const traitIds = document.getElementById('trait-ids').value.trim();
                
                if (!packId || !traitIds) {
                    showStatus('Please fill all required fields', 'error');
                    return;
                }

                if (parseInt(packId) < 100000 || parseInt(packId) > 109999) {
                    showStatus('Pack ID must be between 100000 and 109999', 'error');
                    return;
                }

                // Parse trait IDs array
                const contents = traitIds.split(',').map(id => parseInt(id.trim()));

                // Validate trait IDs
                for (let traitId of contents) {
                    if (traitId < 1 || traitId > 99999) {
                        showStatus(`Trait ID ${traitId} is not in valid range (1-99999)`, 'error');
                        return;
                    }
                }

                showStatus('Creating pack...', 'info');
                
                const tx = await traitsExtensions.createPack(
                    parseInt(packId),
                    contents
                );
                showStatus('Transaction sent, waiting for confirmation...', 'info');
                
                await tx.wait();
                
                showStatus('Pack created successfully!', 'success');
                
                // Clear form
                document.getElementById('pack-id').value = '';
                document.getElementById('trait-ids').value = '';
                
            } catch (error) {
                console.error('Error creating pack:', error);
                showStatus('Failed to create pack: ' + error.message, 'error');
            }
        }

        async function addPackTraits() {
            try {
                console.log('addPackTraits called');
                
                if (!traitsCore) {
                    showStatus('Contract not initialized. Please reconnect your wallet.', 'error');
                    return;
                }
                
                const packId = document.getElementById('config-pack-id').value;
                const traitIds = document.getElementById('trait-ids').value.trim();
                const minAmounts = document.getElementById('min-amounts').value.trim();
                const maxAmounts = document.getElementById('max-amounts').value.trim();
                const chances = document.getElementById('trait-chances').value.trim();
                const poolAmounts = document.getElementById('pool-amounts').value.trim();

                if (!packId || !traitIds || !minAmounts || !maxAmounts || !chances || !poolAmounts) {
                    showStatus('Please fill all fields', 'error');
                    return;
                }

                if (parseInt(packId) < 100000 || parseInt(packId) > 109999) {
                    showStatus('Pack ID must be between 100000 and 109999', 'error');
                    return;
                }

                // Parse arrays
                const traitIdsArray = traitIds.split(',').map(id => parseInt(id.trim()));
                const minAmountsArray = minAmounts.split(',').map(amount => parseInt(amount.trim()));
                const maxAmountsArray = maxAmounts.split(',').map(amount => parseInt(amount.trim()));
                const chancesArray = chances.split(',').map(chance => parseInt(chance.trim()));
                const poolAmountsArray = poolAmounts.split(',').map(amount => parseInt(amount.trim()));

                // Validate arrays have same length
                if (traitIdsArray.length !== minAmountsArray.length ||
                    traitIdsArray.length !== maxAmountsArray.length ||
                    traitIdsArray.length !== chancesArray.length ||
                    traitIdsArray.length !== poolAmountsArray.length) {
                    showStatus('All arrays must have the same length', 'error');
                    return;
                }

                // Validate trait IDs are in valid range
                for (let traitId of traitIdsArray) {
                    if (traitId < 1 || traitId > 99999) {
                        showStatus(`Trait ID ${traitId} is not in valid range (1-99999)`, 'error');
                        return;
                    }
                }

                showStatus('Adding pack traits...', 'info');
                
                const tx = await traitsCore.addPackTraits(
                    parseInt(packId),
                    traitIdsArray,
                    minAmountsArray,
                    maxAmountsArray,
                    chancesArray,
                    poolAmountsArray
                );
                showStatus('Transaction sent, waiting for confirmation...', 'info');
                
                await tx.wait();
                
                showStatus('Pack traits configured successfully!', 'success');
                
                // Clear form
                document.getElementById('config-pack-id').value = '';
                document.getElementById('trait-ids').value = '';
                document.getElementById('min-amounts').value = '';
                document.getElementById('max-amounts').value = '';
                document.getElementById('trait-chances').value = '';
                document.getElementById('pool-amounts').value = '';
                
            } catch (error) {
                console.error('Error adding pack traits:', error);
                showStatus('Failed to add pack traits: ' + error.message, 'error');
            }
        }

        function clearTestResults() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            resultsDiv.style.display = 'block';
        }

        async function testContractConnection() {
            clearTestResults();
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = 'Testing contract connection...<br>';
            try {
                const code = await provider.getCode(TRAITS_CORE);
                resultsDiv.innerHTML += `‚úì Contract deployed: ${code.length > 2 ? 'YES' : 'NO'}<br>`;
                try {
                    const categories = await traitsCore.getCategoryList();
                    resultsDiv.innerHTML += `‚úì Read function works: YES (${categories.length} categories)<br>`;
                    resultsDiv.innerHTML += `Categories: ${categories.join(', ')}<br>`;
                } catch (readError) {
                    resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Read function failed: ${readError.message}</span><br>`;
                }
                try {
                    const owner = await traitsCore.owner();
                    resultsDiv.innerHTML += `‚úì Contract owner: ${owner}<br>`;
                    resultsDiv.innerHTML += `‚úì Your address: ${userAddress}<br>`;
                    resultsDiv.innerHTML += `‚úì You are owner: ${owner.toLowerCase() === userAddress.toLowerCase() ? 'YES' : 'NO'}<br>`;
                } catch (ownerError) {
                    resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Owner check failed: ${ownerError.message}</span><br>`;
                }
                const network = await provider.getNetwork();
                resultsDiv.innerHTML += `‚úì Network: ${network.name} (${network.chainId})<br>`;
                const balance = await provider.getBalance(userAddress);
                resultsDiv.innerHTML += `‚úì ETH Balance: ${ethers.utils.formatEther(balance)} ETH<br>`;
            } catch (error) {
                resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Test failed: ${error.message}</span><br>`;
            }
        }

        async function checkRealOwnership() {
            clearTestResults();
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = 'Checking real ownership...<br>';
            try {
                const ownerCall = await provider.call({
                    to: TRAITS_CORE,
                    data: '0x8da5cb5b'
                });
                const ownerAddress = ethers.utils.defaultAbiCoder.decode(['address'], ownerCall)[0];
                resultsDiv.innerHTML += `Contract owner (direct call): ${ownerAddress}<br>`;
                resultsDiv.innerHTML += `Your address: ${userAddress}<br>`;
                resultsDiv.innerHTML += `Match: ${ownerAddress.toLowerCase() === userAddress.toLowerCase()}<br>`;
                try {
                    const iface = new ethers.utils.Interface(TRAITS_CORE_ABI);
                    const data = iface.encodeFunctionData('addCategory', ['TEST']);
                    const gasEstimate = await provider.estimateGas({
                        to: TRAITS_CORE,
                        from: userAddress,
                        data: data
                    });
                    resultsDiv.innerHTML += `Gas estimate for addCategory: ${gasEstimate.toString()}<br>`;
                    resultsDiv.innerHTML += `‚úì Can call addCategory: YES<br>`;
                } catch (gasError) {
                    resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Cannot call addCategory: ${gasError.message}</span><br>`;
                }
            } catch (error) {
                resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Ownership check failed: ${error.message}</span><br>`;
            }
        }

        async function testReadFunction() {
            clearTestResults();
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = 'Testing read functions...<br>';
            try {
                const categories = await traitsCore.getCategoryList();
                resultsDiv.innerHTML += `Categories (${categories.length}): ${JSON.stringify(categories)}<br>`;
                for (const category of categories) {
                    try {
                        const isValid = await traitsCore.validCategories(category);
                        resultsDiv.innerHTML += `  ${category}: ${isValid ? 'VALID' : 'INVALID'}<br>`;
                    } catch (e) {
                        resultsDiv.innerHTML += `  ${category}: <span style='color:#ff4444'>ERROR - ${e.message}</span><br>`;
                    }
                }
                try {
                    const isValidTrait = await traitsCore.isValidTraitId(1);
                    resultsDiv.innerHTML += `isValidTraitId(1): ${isValidTrait}<br>`;
                } catch (e) {
                    resultsDiv.innerHTML += `isValidTraitId function not available<br>`;
                }
            } catch (error) {
                resultsDiv.innerHTML += `<span style='color:#ff4444'>‚úó Read test failed: ${error.message}</span><br>`;
            }
        }

        // Force enable admin for testing
        function forceEnableAdmin() {
            document.getElementById('admin-panel').classList.add('active');
            showStatus('Admin panel force enabled for testing', 'info');
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.innerHTML = message;
            status.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            console.log('Page loaded, checking status...');
            
            // Status checks
            document.getElementById('metamask-status').textContent = window.ethereum ? 'Installed ‚úì' : 'Not found ‚úó';
            document.getElementById('ethers-status').textContent = typeof ethers !== 'undefined' ? 'Loaded ‚úì' : 'Not loaded ‚úó';
            
            // Auto-connect if already connected
            if (window.ethereum && window.ethereum.selectedAddress) {
                console.log('Wallet already connected, auto-connecting...');
                connectWallet();
            }
        });

        // Listen for account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async function (accounts) {
                console.log('Accounts changed:', accounts);
                if (accounts.length === 0) {
                    // User disconnected
                    document.getElementById('connect-section').style.display = 'block';
                    document.getElementById('wallet-connected').style.display = 'none';
                    document.getElementById('admin-panel').classList.remove('active');
                    userAddress = null;
                    showStatus('Wallet disconnected', 'info');
                } else {
                    // Account changed
                    await connectWallet();
                }
            });

            window.ethereum.on('chainChanged', function (chainId) {
                console.log('Chain changed:', chainId);
                // Reload page on chain change
                window.location.reload();
            });

            window.ethereum.on('disconnect', function() {
                console.log('Wallet disconnected');
                document.getElementById('connect-section').style.display = 'block';
                document.getElementById('wallet-connected').style.display = 'none';
                document.getElementById('admin-panel').classList.remove('active');
                userAddress = null;
                showStatus('Wallet disconnected', 'info');
            });
        }
    </script>
</body>
</html>